#!/bin/zsh -f
# wordstar, version 0.5.1
# copyright 2024 Erik Ben Heckman <erik@heckman.ca>
# shared under the terms of the MIT license

# wordstar: Launch WordStar in an emulated DOS environment on MacOS

# if [[ $1 = --debug ]]; then set -x; shift; fi
set -euo pipefail
trap exit ZERR

# default options
# all but `dosbox_path` can be modified with command-line options
# don't use '~' in paths as it wont be expanded
typeset -A SETTINGS=(
	[dosbox_path]="/Applications/dosbox-x.app/Contents/MacOS/dosbox-x"
	[dosbox_config_path]="$HOME/Applications/WordStar/dosbox-x.conf"
	[c_mount_path]="$HOME/Applications/WordStar/DOS root"
	[wordstar_executable]="WS"
	[fullscreen]=false
	[create_missing_paths]=false
	[shell_only]=false
	[documents_mount_path]=''
	[mount_drive]='D:'
	[verbose]=false
	[help_level]=4
)

typeset -A OPTIONS
# what's left after the options are removed
typeset -a ARGUMENTS

typeset -a DOSBOX_ARGS=(
	-fastlaunch
	-noautoexec
	-set 'sdl fullscreen=false'
	-set 'ttf font=dejavusansmono'
	-set 'ttf fontbold=dejavusansmono-bold'
	-set 'ttf fontital=dejavusansmono-oblique'
	-set 'ttf fontboit=dejavusansmono-boldoblique'
	-set 'ttf ptsize=30'
	-set 'ttf lins=30'
	-set 'ttf cols=96'
)

typeset -a WORDSTAR_ARGS

help(){
	echo "USAGE: wordstar [OPTIONS] [--] [DOCUMENT]

    Launches WordStar in an emulated DOS environment
    using Robert J. Sawyer's WordStar archive: https://sfwriter.com/ws7.htm

    If DOCUMENT doesn't exist, a new document will be opened in WordStar.
    It's name will be appended with .WS if it doesn't already have that
    extension. Note: '--' is required if DOCUMENT begins with a '-'.

    OPTIONS:

    -P <PRESET>, --preset <PRESET>
            Start WordStar with one of the folloing presets:
                pristine   an unmodified out-of-the-box WordStar
                subdued    R.J. Sawyer's custom less-harsh colour scheme
                sawyer     R.J. Sawyer's preferred layout and extensive
                           customizations. Default help level is 2.
            For descriptions of the presets, see the following
            file in Robert J. Sawyer's WordStar archive:
            '${SETTINGS[c_mount_path]%/}/WS/VERSIONS.TXT'

    -H <HELP-LEVEL>, --helplevel <HELP-LEVEL>
            Start WordStar with onethe specified help level:
                0    About help leve 0
                1    About help leve 1
                2    About help leve 2
                3    About help leve 3
                4    About help leve 4 (default)

    -f, --fullscreen
            Run WordStar in fullscreen mode.

    -w, --window,
            Run WordStar in a window, i.e. not fullscreen. (Default.)

    -p, --paths
            When creating a new document, create intermediate
            directories as required.

    -m <DOCUMENT-ROOT>, --mount <DOCUMENT-ROOT>
            Mount the specified path as the document root.
            Only files in this directory tree will be accessible by WordStar.
            With this option, if DOCUMENT is provided as a relative path,
            it will be relative to this path.

            Without this option, the directory containing DOCUMENT
            will be mounted, unless DOCUMENT is itself a directory,
            in which case it itself will be mounted.

    -c <PATH>, --conf <PATH>, --config <PATH>
            Specify a DOSBox-X config file file to use.

    -x <PATH>, --dosbox <PATH>, --dosbox-x <PATH>
            Specify location DOSBox-x program to use.
            Default: '${SETTINGS[dosbox_path]}'.

    -d, --dos, --shell
            Don't launch WordStar, just launch DOSBox-X.

    -r <DOS-ROOT>, --root <DOS-ROOT>, --c-drive <DOS-ROOT>
            Specify a path to mount as the DOS root directory (C: drive)
            This directory must contain the WS directory
            from Robert J. Sawyer's WordStar archive.

    -h, --help
            Print this helpful message and exit.

    -V, --version
            Print version and copyright message and exit.


    ----------------------------------------------------------------------------

    For more information about WordStar, and Robert J. Sawyer's
    WordStar archive, see https://sfwriter.com/ws7.htm

    The archive is stored locally as:
        '${SETTINGS[c_mount_path]%/}/WS/'.

    Its README file can be found here:
        '${SETTINGS[c_mount_path]%/}/WS/-README.TXT'.


"
}


main(){
	local mount_path wordstar_doc

	set_SETTINGS_and_ARGUMENTS "$@"
	# printf "%s\n" "${ARGUMENTS[@]}"

	mount_path="$(get_mount_path "${ARGUMENTS[1]:-.}")"
	# printf "mount_path='%s'\n" "$mount_path" >&2
	wordstar_doc="$(get_wordstar_document "$mount_path" "${ARGUMENTS[1]:-.}")"
	wordstar_doc="$(validate_8.3_path "$wordstar_doc")"


	# printf "wordstar_doc='%s'\n" "$wordstar_doc" >&2

	set_wordstar_arguments "$wordstar_doc"
	set_dosbox_arguments "$mount_path"
	launch_dosbox

	# print_globals
	# exit

}
set_wordstar_arguments(){ local wordstar_doc="$1"
 	WORDSTAR_ARGS+=( "/h${SETTINGS[help_level]}" "$wordstar_doc" )
}

launch_dosbox(){
	if ${SETTINGS[verbose]}
	then
		"${SETTINGS[dosbox_path]}" "${DOSBOX_ARGS[@]}"
	else
		"${SETTINGS[dosbox_path]}" "${DOSBOX_ARGS[@]}" &> /dev/null
	fi
}

set_dosbox_arguments(){ local mount_path="$1"
	DOSBOX_ARGS+=(
		-c "@mount -q ${SETTINGS[mount_drive]%:}: \"${mount_path}\""
		-c "@${SETTINGS[mount_drive]%:}:"
		-conf "${SETTINGS[dosbox_config_path]}"
		-c "@mount -q C: \"${SETTINGS[c_mount_path]}\""
	)

	if $SETTINGS[fullscreen]
	then
		DOSBOX_ARGS+=(-fullscreen)
	fi

	if ${SETTINGS[shell_only]}
	then
		DOSBOX_ARGS+=(
			-c "@mount D:"
			-c "@echo WordStar arguments are: ${WORDSTAR_ARGS[*]}"
		)
	else
		DOSBOX_ARGS+=(
			-c "@${SETTINGS[wordstar_executable]} ${WORDSTAR_ARGS[*]}"
			-c "@EXIT"
		)
	fi
}



function process_option(){ local key=$1 value=${2:-}
	case $key in
	help) help; exit;;
	version) version; exit;;
	config) SETTINGS[dosbox_config_path]=$value;;
	c-drive) SETTINGS[c_mount_path]=$value;;
	shell) SETTINGS[shell_only]=true;;
	verbose) SETTINGS[verbose]=true;;
	fullscreen) SETTINGS[fullscreen]=true;;
	window) SETTINGS[fullscreen]=false;;
	paths) SETTINGS[create_missing_paths]=true ;;
	mount) SETTINGS[documents_mount_path]="${value%/}/";;
	preset) case $value in
		pristine) SETTINGS[wordstar_executable]=PRISTINE;;
		subdues) SETTINGS[wordstar_executable]=WSRJS;;
		sawyer) SETTINGS[wordstar_executable]=SAWYER;;
		*) die "invalid preset: $value";;
		esac;;
	helplevel) case $value in
		<0-4>) SETTINGS[help_level]=$value;;
		*) die "invalid help level: $value";;
		esac;;
	dosbox-x) SETTINGS[dosbox_path]=$value;;
	*) die "invalid option: $key";;
	esac
}

# parses command-line options and sets elements of global SETTINGS appropriately
# leaves the remaining command-line arguments in global ARGUMENTS
set_SETTINGS_and_ARGUMENTS(){
	# zparseopts produces unsightly error messages
	# e.g.:
	#   main:zparseopts:3: bad option: -a
	#   main:zparseopts:3: missing argument for option: -H
	#
	# this workaround uses a temporary file... it's the only way I could find
	# that avoided running `zparseopts` in a subshell
	local zparsopts_errors=$(mktemp)
	trap "if [[ -f $zparsopts_errors ]]; then rm $zparsopts_errors; fi" EXIT

	# don't panic on error, we'll die later
	zparseopts -F -M -D -A COMMAND_LINE_OPTIONS \
		$(help | help_opts) 2> $zparsopts_errors || :

	# die if errors were output
	if [[ -s $zparsopts_errors ]]; then
		die "$(cat $zparsopts_errors | sed 's/^[^ ]* //')"
	fi

	# process each option
	for k v in "${(@kv)COMMAND_LINE_OPTIONS}"
	do process_option ${k#--} $v
	done

	validate_settings

	# save the rest of the command-line arguments
	ARGUMENTS=("$@")
}


get_mount_path(){ local target="${1:-.}"
	dirname_unless_slash_terminated \
		"${SETTINGS[documents_mount_path]:-"$target"}" |
			validate_mount_path
}
dirname_unless_slash_terminated(){
	print ${${1/*/${1}_}:A:h}
}

validate_mount_path(){ local mount_path="$(cat -)"
	if [[ ! -d "$mount_path" ]]
	then
		if ${SETTINGS[create_missing_paths]}
		then
			mkdir -p "$mount_path"
		else
			die "Directory '$mount_path' doesn't exist, use the -p option to create it."
		fi
	fi
	printf "%s" "$mount_path"
}

validate_8.3_path(){ local path="${1}"
	for segment in ${(s:\:)path}
	do
		if [[ -n $segment ]] && ! is_valid_8.3_filename "$segment"
		then
			printf "%s" "$path"
			die "path not in 8.3 format: $path"
		fi
	done
	# printf "8.3 path: '%s'\n" "$path" >&2
	printf "%s" "$path"
}

is_valid_8.3_filename(){ local filename="$1"
	/usr/bin/grep -qE '^[A-Za-z0-9!#$%&'"'"'()@^_`{}~-]{1,8}(\.[A-Za-z0-9!#$%&'"'"'()@^_`{}~-]{0,3})?$' <<<"$filename"
}

validate_settings(){
	validate_executable ${SETTINGS[dosbox_path]} "dosbox-x"
	validate_file ${SETTINGS[dosbox_config_path]} "config file"
	[[ -d ${SETTINGS[c_mount_path]} ]] ||
		die "cant find C: mount path: '${SETTINGS[c_mount_path]}'"

}

get_wordstar_document(){ local mount_path="${1}" target_document="${2}"
	target_document="$(
		descendent "${target_document:A}" "${mount_path}" |
			reverse_slashes
	)" || die "document '${target_document}' not accesible in mounted path '${mount_path}'"
	printf "%s" "$target_document"
}



# if target is in directory, or one of it's descendent directories
# then print its relative path. Otherwise, print the target and return 1
descendent(){ local target=$1 directory=$2
	# printf "target=%s\n" "$target" >&2
	# printf "directory=%s\n" "$directory" >&2
	if [[ "${target}" = "${directory%/}"*  ]]
	then
		# printf "\ntarget=%s\n" "$target" >&2
		# printf "directory=%s\n\n" "$directory" >&2
		printf "%s" "${target#$directory}"
	else
		printf "%s" "$target"
		return 1
	fi
}

validate_executable(){ local file=$1 name=${2:-file}
	[[ -x $file ]] || die "cant execute ${name}: '$file'"
}

validate_file() { local file=$1 name=${2:-file}
	[[ -r $file ]] || die "cant read ${name}: '$file'"
}

validate_dir(){ local dir=$1 name=${2:-directory}
	[[ -d $dir ]] || die "cant find ${name}: '$dir'"
}

reverse_slashes(){
	sed 's|//*|\\|g'
}

version(){
	/usr/bin/awk '/^#!/{next}/^#/{sub("^# *","");print;next}{exit}' "$ZSH_ARGZERO"
}

# relies on `set -e` to exit on error
die(){
	printf "%s\n" "$1">&2
	exit 77
}

print_globals(){
	set | grep -E '^(SETTINGS|COMMAND_LINE_OPTIONS|ARGS|DOSBOX_ARGS|WORDSTAR_ARGS)='
}

help_opts(){ /usr/bin/awk '
# help_opts v1.0 2024-08-17

function initialize_option(){
	OPTION_BUFFER=""
	REQUIRED_ARGUMENT=0
	OPTIONAL_ARGUMENT=0
}
function add_option(name,key,req_arg,opt_arg){
	OPTIONS=OPTIONS" "name""(req_arg ? ":" : (opt_arg ? "::" : ""))(key?"="key:"")
}
function end_of_option(a,key,o){
	split(OPTION_BUFFER,a," ")
	key=a[1]
	delete a[1]
	add_option(key,"",REQUIRED_ARGUMENT,OPTIONAL_ARGUMENT)
	for (o in a) add_option(a[o],key,REQUIRED_ARGUMENT,OPTIONAL_ARGUMENT)
	initialize_option()
}
BEGIN{
	FS="[\t, ]+"
	initialize_option()
	OPTIONS=""
}
/\s*[^-]/{
	for ( f=1; f<=NF; f++)
		if ($f=="")
			continue
		else if (match($f, /^--?[a-zA-Z0-9][a-zA-Z0-9_-]*$/))
			OPTION_BUFFER=substr($f,2)" "OPTION_BUFFER
		else if (match($f, /^<.*>$/))
			REQUIRED_ARGUMENT=1
		else if (match($f, /^\[<.*>\]$/))
			OPTIONAL_ARGUMENT=1
		else
			end_of_option()
}
{
	if (OPTION_BUFFER) end_of_option()
}
END {
	print OPTIONS
}

'
}
main "$@"

