#!/bin/zsh -f
# wordstar, version 0.5.1
# copyright 2024 Erik Ben Heckman <erik@heckman.ca>
# shared under the terms of the MIT license


# wordstar launcher: Launch WordStar in an emulated DOS environment on MacOS


# this version defines settings and command-line options in the help text

setopt NO_UNSET PIPE_FAIL ERR_RETURN

# APP_DATA is only used in the following initialization of SETTINGS
readonly APP_DATA="$HOME/Applications/WordStar"
# most default settings are defined in the help text,
# and override any defined here
typeset -A SETTINGS=(
	[c_mount_path]="$APP_DATA/DOS root"
	[dosbox_config_path]="$APP_DATA/DOS root/WS/DOSBox-X/dosbox-x.conf"
	[dosbox_mapper_path]="$APP_DATA/mapper-dosbox-x.map"
	# [dosbox_path]="/opt/homebrew/bin/dosbox-x"
	[dosbox_path]="/Applications/dosbox-x.app/Contents/MacOS/dosbox-x"
	[mount_drive]=D: # anything but C: or Z: is ok.
)


typeset -a DOSBOX_ARGS=(
	-fastlaunch
	-noautoexec
	-set 'sdl fullscreen=false'
	-set 'ttf font=dejavusansmono'
	-set 'ttf fontbold=dejavusansmono-bold'
	-set 'ttf fontital=dejavusansmono-oblique'
	-set 'ttf fontboit=dejavusansmono-boldoblique'
	-set 'ttf ptsize=30'
	-set 'ttf lins=30'
	-set 'ttf cols=96'
)


# error codes
ERR_BAD_OPTIONS=69
ERR_NO_DOC_MOUNT=6
ERR_NO_NEW_DOC_MOUNT=7
ERR_NO_ACCESS=8
ERR_BAD_TARGET=9
ERR_BAD_DOS_NAME=10
ERR_BAD_SETTING=11
ERR_NO_EXEC=12
ERR_NO_DIR=13
ERR_NO_READ=14
ERR_INTERNAL=66

readonly -A ERROR_MESSAGES=(
	[$ERR_BAD_SETTING]="invalid %s: %s"
	[$ERR_BAD_TARGET]="target document '%s' exists and is not a file or directory."
	[$ERR_BAD_DOS_NAME]="path to '%s' not in DOS 8.3 format"
	[$ERR_NO_DOC_MOUNT]="'%s' is not a directory, use the -p option to create it."
	[$ERR_NO_NEW_DOC_MOUNT]="can't create directory for document mount-point: %s"
	[$ERR_NO_ACCESS]="document '%s' is not accessible from document mount point '%s'."
	[$ERR_NO_EXEC]="can't execute %s file: %s"
	[$ERR_NO_DIR]="can't find %s directory: %s"
	[$ERR_NO_READ]="can't read %s file: %s"
	[$ERR_INTERNAL]="internal error: %s"
)

typeset -a ARGUMENTS
typeset -a WORDSTAR_ARGS

annotated_help(){
	echo "USAGE: wordstar [OPTIONS] [--] [DOCUMENT]

    Launches WordStar in an emulated DOS environment provided by DOSBox-X
    using Robert J. Sawyer's WordStar archive: https://sfwriter.com/ws7.htm

	Both BOSBox-X and Robert J. Sawyer's Archive are required.

    If DOCUMENT doesn't exist, a new document will be opened in WordStar.
    It's name will be appended with .WS if it doesn't already have that
    extension. Note: '--' is required if DOCUMENT begins with a '-'.

    OPTIONS:

    -P <PRESET>, --preset <PRESET> # wordstar_executable WS
            Start WordStar with one of the following presets: # -c preset
                pristine   an unmodified out-of-the-box WordStar # PRISTINE
                subdued    R.J. Sawyer's custom less-harsh colour scheme # WSRJS
                sawyer     R.J. Sawyer's preferred layout and extensive # SAWYER
                           customizations. Default help level is 2.
            For descriptions of the presets, see '/WS/VERSIONS.TXT'
            in Robert J. Sawyer's WordStar archive.


    -H <HELP-LEVEL>, --helplevel <HELP-LEVEL> # help_level 4
            Start WordStar with one the specified help levels: # -c help level
                0    help-level 0 #
                1    help-level 1 #
                2    help-level 2 #
                3    help-level 3 #
                4    help-level 4 (default) #

    -f, --fullscreen # fullscreen false
            Toggle fullscreen mode. By default WordStar runs in a window.

    -p, --paths # create_missing_paths
            When creating a new document, create intermediate
            directories as required.

    -d <DOCUMENT-ROOT>, --documents <DOCUMENT-ROOT> # documents_mount_path
            Mount the specified path as the document root. # -d "document root"
            Only files in this directory tree will be accessible by WordStar.
            With this option, if DOCUMENT is provided as a relative path,
            it will be relative to this path.

            Without this option, the directory containing DOCUMENT
            will be mounted, unless DOCUMENT is itself a directory,
            in which case it itself will be mounted.

    -c <PATH>, --conf <PATH>, --config <PATH> # dosbox_config_path
            Specify a DOSBox-X config file file to use. # -r "dosbox config"

	-m <PATH>, --mapper # dosbox_mapper_path
            Specify a DOSBox-X key-mapper file file to use. # -r "dosbox mapper"

    -x <PATH>, --dosbox <PATH>, --dosbox-x <PATH> # dosbox_path
            Specify location DOSBox-x program to use. # -x dosbox

    -s, --dos, --shell # shell_only
            Don't launch WordStar, just launch DOSBox-X.

    -r <DOS-ROOT>, --root <DOS-ROOT>, --c-drive <DOS-ROOT> # c_mount_path
            Specify a path to mount as the DOS root directory (C: drive) # -d "dos root"
            This directory must contain the WS directory
            from Robert J. Sawyer's WordStar archive.

    -v, --verbose # verbose
            Print debugging information.

    -h, --help # help()
            Print this helpful message and exit.

    -V, --version # version()
            Print version and copyright message and exit.


    ----------------------------------------------------------------------------

    For more information about WordStar, and Robert J. Sawyer's
    WordStar archive, see https://sfwriter.com/ws7.htm

"
}

if [[ $1 == "debug" ]]; then help; exit; fi

print_env(){
	set | grep -E "^(${(j:|:)@})=" >&2
}

print_globals(){
	print_env OPTIONS ARGUMENTS SETTINGS DOSBOX_ARGS WORDSTAR_ARGS
	# set | grep -E '^(SETTINGS|COMMAN_LINE_ARGUMENTS|DOSBOX_ARGS|WORDSTAR_ARGS)=' >&2
}


peek(){
	# set | grep "^$1="
}
peek2(){
	set | grep "^$1="
}


main(){

	local argument target mount_path wordstar_document

	set_SETTINGS_and_ARGUMENTS "$@"

	argument=${ARGUMENTS[1]:-.}

	doc_mount=$(get_doc_mount "$argument") || invalid "$doc_mount" # uses SETTINGS
	target=$(get_target $argument $doc_mount ) || invalid "$target" "$doc_mount"
	ws_doc=$(get_ws_doc $doc_mount $target) || invalid "$ws_doc"

	# peek2 doc_mount
	# exit

	set_WORDSTAR_ARGS "$ws_doc" # uses SETTINGS

	set_DOSBOX_ARGS "$doc_mount" # uses WORDSTAR_ARGS and SETTINGS

	# print_globals; exit

	launch_dosbox
}

get_doc_mount(){ local arg=$1 doc_mount

	if [[ -v SETTINGS[documents_mount_path] ]]
	then
		doc_mount=${SETTINGS[documents_mount_path]}

	elif [[ -d $1 ]] || [[ ! -e $1 && "${1[-1]}" = "/" ]]
	then
		doc_mount=${arg}
	else
		doc_mount=${arg:h}
	fi

	printf %s "${doc_mount:A}"

	# validation
	[[ -d "$doc_mount" ]] && return
	${SETTINGS[create_missing_paths]} || return $ERR_NO_DOC_MOUNT
	mkdir -p $doc_mount > /dev/null || return $ERR_NO_NEW_DOC_MOUNT
}


get_target(){ local target=${1:A} directory=${2:A}
	printf "%s" "$target"
	[[ -d $target || -f $target || ! -e $target ]] || return $ERR_BAD_TARGET
	[[ $target = $directory*  ]] || return $ERR_NO_ACCESS
}


get_ws_doc(){ local directory=$1 target=$2 segments segment
	segments=( ${(s:/:)target#$directory} )
	printf '\\%s' "${segments[@]}"
	# validation
	for segment in $segments
	do
		is_valid_dos_name $segment || return $ERR_BAD_DOS_NAME
	done
}


set_WORDSTAR_ARGS(){ local wordstar_document="$1"
 	WORDSTAR_ARGS+=( "/h${SETTINGS[help_level]}" "$wordstar_document" )
}

set_DOSBOX_ARGS(){ local mount_path="$1"
	DOSBOX_ARGS+=(
		-conf "${SETTINGS[dosbox_config_path]}"
		-set mapperfile="${SETTINGS[dosbox_mapper_path]}"
		-c "@mount -q ${SETTINGS[mount_drive]%:}: \"${mount_path}\""
		-c "@${SETTINGS[mount_drive]%:}:"
		-c "@mount -q C: \"${SETTINGS[c_mount_path]}\""
	)

	if $SETTINGS[fullscreen]
	then
		DOSBOX_ARGS+=(-fullscreen)
	fi

	if ${SETTINGS[shell_only]}
	then
		DOSBOX_ARGS+=(
			-c "@mount D:"
			-c "@echo WordStar arguments are: ${WORDSTAR_ARGS[*]}"
		)
	else
		DOSBOX_ARGS+=(
			-c "@${SETTINGS[wordstar_executable]} ${WORDSTAR_ARGS[*]}"
			-c "@EXIT"
		)
	fi
}

launch_dosbox(){
	if ${SETTINGS[verbose]}
	then
		"${SETTINGS[dosbox_path]}" "${DOSBOX_ARGS[@]}"
	else
		"${SETTINGS[dosbox_path]}" "${DOSBOX_ARGS[@]}" &> /dev/null
	fi
}

invalid(){
	error $? "$@"
}

error(){ local error_code=$1; shift #...error-message arguments
	if [[ -v ERROR_MESSAGES[$error_code] ]]
	then die "$(printf "$ERROR_MESSAGES[$error_code]" "$@")" $error_code
	else die "unknown error '$error_code' with arguments: $*"
	fi
}

is_valid_dos_name(){ local filename=$1
	/usr/bin/grep -qE '^[A-Za-z0-9!#$%&'"'"'()@^_`{}~-]{1,8}(\.[A-Za-z0-9!#$%&'"'"'()@^_`{}~-]{0,3})?$' <<<"$filename"
}

help(){
	annotated_help | sed -E 's/[ \t]*#.*$//'
	exit
}
version(){
	/usr/bin/awk '/^#!/{next}/^#/{sub("^# *","");print;next}{exit}' "$ZSH_ARGZERO"
	exit
}

die(){ local message=$1 code=${2:-$?}
	print -r $message >&2
	exit $code
}

set_SETTINGS_and_ARGUMENTS(){
	local -a help_opts_out
	local options_definition_string
	local -A functions commandline_options option_map defaults settings validations validation_parameters

	help_opts_out=( "${(@f)$(annotated_help | help_opts)}" )
	# peek help_opts_out

	options_definition_string=${help_opts_out[1]}

	functions=( ${(Q)${(z)help_opts_out[2]}} )
	option_map=( ${(Q)${(z)help_opts_out[3]}} )
	defaults=( ${(Q)${(z)help_opts_out[4]}} )
	validations=( ${(Q)${(z)help_opts_out[5]}} )
	validation_parameters=( ${(Q)${(z)help_opts_out[6]}} )

	peek options_definition_string
	zparseopts -F -M -D -A commandline_options ${=options_definition_string} \
		2> >(sed -e 's/^[^ ]* //' >&2) || exit $ERR_BAD_OPTIONS

	peek commandline_options
	peek option_map
	ARGUMENTS=("$@")

	settings=( ${(kv)defaults} )

	# apply command-line options to settings
	for option value in "${(@kv)commandline_options}"
	do
		peek option
		peek value
		peek functions
		if [[ -v functions[$option] ]]
		then
			$functions[$option] $value
		elif [[ -n $value ]]
		then settings[${option_map[$option]}]=$value
		else case ${settings[${option_map[$option]}]:-} in
			true) settings[${option_map[$option]}]=false;;
			false) settings[${option_map[$option]}]=true;;
			*) settings[${option_map[$option]}]="";;
			esac
		fi
	done

	peek settings

	# validate settings
	local -a validation_types
	local -A validation_choices
	# peek validations
	for setting value in "${(@kv)settings}"
	do
		if [[ -v validations[$setting] ]]
		then
			set -- ${=validations[$setting]}
			# echo "${validations[$setting]}"
			zparseopts -D -F -a validation_types d x r c
			# peek validation_types
			for type in "${validation_types[@]}"
			do case $type in
				-d) [[ -d $value ]] || error $ERR_NO_DIR "$*" $value;;
				-x) [[ -x $value ]] || error $ERR_NO_EXEC "$*" $value;;
				-r) [[ -r $value ]] || error $ERR_NO_READ "$*" $value;;
				-c) validation_choices=( ${(Q)${(z)validation_parameters[$setting]}} )
					# peek validation_choices
					if [[ $value != ${defaults[$setting]} ]]
					then
						[[ -v validation_choices[$value] ]] ||
							error $ERR_BAD_SETTING "$*" $value
						settings[$setting]=${validation_choices[$value]}
					fi
					;;
				*) error $ERR_INTERNAL "type=$type, value=$value, args=$*";;
				esac
			done
		fi
	done
	peek settings
	SETTINGS=( ${(kv)SETTINGS} ${(kv)settings} )
}

# generate zparseopt string from help string
help_opts(){ /usr/bin/awk '
#!/usr/bin/awk -f

# help_opts v2.0 2024-09-05
function rem( pos){
	if (pos=index($0,"#")) return substr($0,pos+1)
}
function is_arg(){
	if (match($f, /^<.*>$/)) return ":"
	if (match($f, /^\[<.*>\]$/)) return "::"
}
function print_array(array,quotes){
	for (key in array)
		printf("%s %s%s%s ",key,quotes,array[key],quotes)
	printf "\n"
}

BEGIN{
	FS="[\t, ]+"
}
# { print "==" $0 "==" }
{
	N1=1; while(!$N1&&N1<=NF&&$N1!=0) N1++
}
/^[ \t]*--?[a-zA-Z0-9]/{
  # print "<" $1 ">"
	KEY=substr($N1,2)
	ARGS=""
	for ( f=N1; f<=NF; f++ ) if (ARGS=is_arg()) break
	for ( f=N1; f<=NF; f++ )
		if (match($f, /^--?[a-zA-Z0-9][a-zA-Z0-9_-]*$/))
			OPTIONS=OPTIONS " " substr($f,2) ARGS "=" KEY
	if (match(comments=rem(), /^ *!?[a-zA-Z0-9][a-zA-Z0-9_-]* */)) {
		SETTING=substr(comments,1,RLENGTH)
		default=substr(comments,1+RLENGTH)
		if (default=="()")
			FUNCTIONS["-" KEY] = SETTING
		else {
			SETTINGS["-" KEY] = SETTING
			if (ARGS) {
				if (default!="") DEFAULTS[SETTING]=default
			} else {
				DEFAULTS[SETTING] = (default!="")? default : "false"
			}
		}
	}
	next
}
/#/{
	if (VALIDATIONS[SETTING]) {
		if (match(comments=rem(),/^[ \t]*$/)) comments=$N1
		VALID_PARAMS[SETTING]= VALID_PARAMS[SETTING] " " $N1 " " comments
	} else {
		VALIDATIONS[SETTING]=rem()
	}
}

END {
	# print("OPTIONS")
	print(OPTIONS)
	# print("FUNCTIONS")
	print_array(FUNCTIONS)
	# print("SETTINGS")
	print_array(SETTINGS)
	# print("DEFAULTS")
	print_array(DEFAULTS)
	# print("VALIDATIONS")
	print_array(VALIDATIONS,"\"")
	# print("VALID_PARAMS")
	print_array(VALID_PARAMS,"\"")
}
'
}
main "$@"


