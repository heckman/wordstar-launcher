#!/bin/zsh -f
# wordstar, version 0.5.1
# copyright 2024 Erik Ben Heckman <erik@heckman.ca>
# shared under the terms of the MIT license


# wordstar launcher: Launch WordStar in an emulated DOS environment on MacOS


if [[ $1 = --debug ]]; then set -x; shift; fi
set -euo pipefail
# trap exit ZERR

# default options
# all but `dosbox_path` can be modified with command-line options
# don't use '~' in paths as it wont be expanded

# [dosbox_path]="/opt/homebrew/bin/dosbox-x"

typeset -A SETTINGS=(
	[dosbox_path]="/Applications/dosbox-x.app/Contents/MacOS/dosbox-x"
	[dosbox_config_path]="$HOME/Applications/WordStar/DOS root/WS/DOSBox-X/dosbox-x.conf"
	[dosbox_mapper_path]="$HOME/Applications/WordStar/mapper-dosbox-x.map"
	[c_mount_path]="$HOME/Applications/WordStar/DOS root"
	[wordstar_executable]="WS"
	[fullscreen]=false
	[create_missing_paths]=false
	[shell_only]=false
	[documents_mount_path]=''
	[mount_drive]='D:'
	[verbose]=false
	[help_level]=4
)

typeset -a DOSBOX_ARGS=(
	-fastlaunch
	-noautoexec
	-set 'sdl fullscreen=false'
	-set 'ttf font=dejavusansmono'
	-set 'ttf fontbold=dejavusansmono-bold'
	-set 'ttf fontital=dejavusansmono-oblique'
	-set 'ttf fontboit=dejavusansmono-boldoblique'
	-set 'ttf ptsize=30'
	-set 'ttf lins=30'
	-set 'ttf cols=96'
)

typeset -a ARGUMENTS
typeset -a WORDSTAR_ARGS

help(){
	echo "USAGE: wordstar [OPTIONS] [--] [DOCUMENT]

    Launches WordStar in an emulated DOS environment
    using Robert J. Sawyer's WordStar archive: https://sfwriter.com/ws7.htm

    If DOCUMENT doesn't exist, a new document will be opened in WordStar.
    It's name will be appended with .WS if it doesn't already have that
    extension. Note: '--' is required if DOCUMENT begins with a '-'.

    OPTIONS:

    -P <PRESET>, --preset <PRESET>
            Start WordStar with one of the folloing presets:
                pristine   an unmodified out-of-the-box WordStar
                subdued    R.J. Sawyer's custom less-harsh colour scheme
                sawyer     R.J. Sawyer's preferred layout and extensive
                           customizations. Default help level is 2.
            For descriptions of the presets, see the following
            file in Robert J. Sawyer's WordStar archive:
            '${SETTINGS[c_mount_path]%/}/WS/VERSIONS.TXT'

    -H <HELP-LEVEL>, --helplevel <HELP-LEVEL>
            Start WordStar with onethe specified help level:
                0    About help leve 0
                1    About help leve 1
                2    About help leve 2
                3    About help leve 3
                4    About help leve 4 (default)

    -f, --fullscreen
            Run WordStar in fullscreen mode.

    -w, --window
            Run WordStar in a window, i.e. not fullscreen. (Default.)

    -p, --paths
            When creating a new document, create intermediate
            directories as required.

    -d <DOCUMENT-ROOT>, --documents <DOCUMENT-ROOT>
            Mount the specified path as the document root.
            Only files in this directory tree will be accessible by WordStar.
            With this option, if DOCUMENT is provided as a relative path,
            it will be relative to this path.

            Without this option, the directory containing DOCUMENT
            will be mounted, unless DOCUMENT is itself a directory,
            in which case it itself will be mounted.

    -c <PATH>, --conf <PATH>, --config <PATH>
            Specify a DOSBox-X config file file to use.

	-m <PATH>, --mapper
            Specify a DOSBox-X key-mapper file file to use.

    -x <PATH>, --dosbox <PATH>, --dosbox-x <PATH>
            Specify location DOSBox-x program to use.
            Default: '${SETTINGS[dosbox_path]}'.

    -s, --dos, --shell
            Don't launch WordStar, just launch DOSBox-X.

    -r <DOS-ROOT>, --root <DOS-ROOT>, --c-drive <DOS-ROOT>
            Specify a path to mount as the DOS root directory (C: drive)
            This directory must contain the WS directory
            from Robert J. Sawyer's WordStar archive.

    -h, --help
            Print this helpful message and exit.

    -V, --version
            Print version and copyright message and exit.


    ----------------------------------------------------------------------------

    For more information about WordStar, and Robert J. Sawyer's
    WordStar archive, see https://sfwriter.com/ws7.htm

    The archive is stored locally as:
        '${SETTINGS[c_mount_path]%/}/WS/'.

    Its README file can be found here:
        '${SETTINGS[c_mount_path]%/}/WS/-README.TXT'.


"
}

print_env(){
	set | grep -E "^(${(j:|:)@})=" >&2
}

print_globals(){
	print_env SETTINGS ARGUMENTS DOSBOX_ARGS WORDSTAR_ARGS
	# set | grep -E '^(SETTINGS|ARGUMENTS|DOSBOX_ARGS|WORDSTAR_ARGS)=' >&2
}

peek(){ printf "%s='%s'\n" $1 $2 >&2; }

main(){
	local target mount_path wordstar_document

	set_SETTINGS_and_ARGUMENTS "$@"
	validate_settings

	target="${${ARGUMENTS[1]:-.}}"
	mount_path="${$(resolve_mount_path "$target")}"
	validate_mount_path $mount_path
	validate_target $target $mount_path

	# WordStar program will open document at this DOS path
	wordstar_document="${$(resolve_wordstar_document "$target" "$mount_path"):-\\}"
	validate_wordstar_document $wordstar_document

	# use the SETTINGS global variable to set DOSBOX_ARGS and WORDSTAR_ARGS
	set_wordstar_arguments "$wordstar_document"
	set_dosbox_arguments "$mount_path" # uses WORDSTAR_ARGS

	# print_globals; exit

	launch_dosbox
}

validate_settings(){
	(){ [[ -x $1 ]] || die_by NO_DOSBOX $1;} ${SETTINGS[dosbox_path]}
	(){ [[ -r $1 ]] || die_by NO_CONFIG $1;} ${SETTINGS[dosbox_config_path]}
	(){ [[ -d $1 ]] || die_by NO_C_MOUNT $1;} ${SETTINGS[c_mount_path]}
}

validate_mount_path(){ local dir=$1
	[[ -d "$dir" ]] && return
	${SETTINGS[create_missing_paths]} || die_by NO_DOC_MOUNT "$dir"
	mkdir -p $dir > /dev/null || die_by NO_NEW_DOC_MOUNT $dir
}

validate_target(){ local target=${1:A} directory=${2:A}
	[[ $target = $directory*  ]] || die_by NO_ACCESS "$target" "$directory"
	[[ -d $target || -f $target || ! -e $target ]] ||
		die_by BAD_TARGET_TYPE "$target"
}

validate_wordstar_document(){ local dos_path=$1
	is_valid_8.3_path "$dos_path" || die_by BAD_DOS_NAME "$dos_path"
}

resolve_mount_path(){ local target=$1
	if [[ -n ${SETTINGS[documents_mount_path]} ]]; then
		printf "%s" ${SETTINGS[documents_mount_path]}
	elif [[ -d $target ]]; then
		printf "%s" ${target}
	elif [[ -e $target ]]; then
		printf "%s" ${target:h}
	elif [[ "${target[-1]}" = "/" ]]; then
		printf "%s" ${target}
	else
		printf "%s" ${target:h}
	fi
}

resolve_wordstar_document(){ local target=${1:A} directory=${2:A}
	reverse_forward_slashes <<<${target#$directory}
}


set_wordstar_arguments(){ local wordstar_document="$1"
 	WORDSTAR_ARGS+=( "/h${SETTINGS[help_level]}" "$wordstar_document" )
}

set_dosbox_arguments(){ local mount_path="$1"
	DOSBOX_ARGS+=(
		-conf "${SETTINGS[dosbox_config_path]}"
		-set mapperfile="${SETTINGS[dosbox_mapper_path]}"
		-c "@mount -q ${SETTINGS[mount_drive]%:}: \"${mount_path}\""
		-c "@${SETTINGS[mount_drive]%:}:"
		-c "@mount -q C: \"${SETTINGS[c_mount_path]}\""
	)

	if $SETTINGS[fullscreen]
	then
		DOSBOX_ARGS+=(-fullscreen)
	fi

	if ${SETTINGS[shell_only]}
	then
		DOSBOX_ARGS+=(
			-c "@mount D:"
			-c "@echo WordStar arguments are: ${WORDSTAR_ARGS[*]}"
		)
	else
		DOSBOX_ARGS+=(
			-c "@${SETTINGS[wordstar_executable]} ${WORDSTAR_ARGS[*]}"
			-c "@EXIT"
		)
	fi
}

launch_dosbox(){
	if ${SETTINGS[verbose]}
	then
		"${SETTINGS[dosbox_path]}" "${DOSBOX_ARGS[@]}"
	else
		"${SETTINGS[dosbox_path]}" "${DOSBOX_ARGS[@]}" &> /dev/null
	fi
}


die_by(){ cause=$1; shift
	case $cause in
	NO_DOSBOX) die "cant execute dosbox-x: '$1'." 3;;
	NO_CONFIG) die "cant read config file: '$1'." 4;;
	NO_C_MOUNT) die "cant find C: mount path: '$1'." 5;;
	NO_DOC_MOUNT)
		die "'$1' is not a directory, use the -p option to create it." 6;;
	NO_NEW_DOC_MOUNT)
		die "cannot create directory '$1' for document mount-point." 7;;
	NO_ACCESS)
		die "document '$1' not within mounted tree rooted at '$2'." 8;;
	BAD_TARGET_TYPE)
		die "target document '$1' exists and is not a file or directory." 9;;
	BAD_DOS_NAME)
		die "path to '$1' not in DOS 8.3 format" 10;;
	INVALID_PARAMETER)
		die "invalid $1: '$2'" 11;;
	*)
		die "unknown error: '$cause'" 2;;
	esac
}

function process_option(){ local key=$1 value=${2:-}
	case $key in
	help) help; exit;;
	version) version; exit;;
	config) SETTINGS[dosbox_config_path]=$value;;
	mapper) SETTINGS[dosbox_mapper_path]=$value;;
	c-drive) SETTINGS[c_mount_path]=$value;;
	shell) SETTINGS[shell_only]=true;;
	verbose) SETTINGS[verbose]=true;;
	fullscreen) SETTINGS[fullscreen]=true;;
	window) SETTINGS[fullscreen]=false;;
	paths) SETTINGS[create_missing_paths]=true ;;
	documents) SETTINGS[documents_mount_path]="$value";;
	preset) case $value in
		pristine) SETTINGS[wordstar_executable]=PRISTINE;;
		subdues) SETTINGS[wordstar_executable]=WSRJS;;
		sawyer) SETTINGS[wordstar_executable]=SAWYER;;
		*) die_by INVALID_PARAMETER preset $value;;
		esac;;
	helplevel) case $value in
		<0-4>) SETTINGS[help_level]=$value;;
		*) die_by INVALID_PARAMETER help-level $value;;
		esac;;
	dosbox-x) SETTINGS[dosbox_path]=$value;;
	*) die_by INVALID_PARAMETER option $key;;
	esac
}


## the functions that follow could moved to external libraries


# parses command-line options and sets elements of global SETTINGS appropriately
# leaves the remaining command-line arguments in global ARGUMENTS
set_SETTINGS_and_ARGUMENTS(){
	# zparseopts produces unsightly error messages
	# e.g.:
	#   main:zparseopts:3: bad option: -a
	#   main:zparseopts:3: missing argument for option: -H
	#
	# this workaround uses a temporary file... it's the only way I could find
	# that avoided running `zparseopts` in a subshell
	local command_line_options
	zparseopts_errors=$(mktemp)  zparseopts_errors=$(mktemp)
	trap "if [[ -f $zparseopts_errors ]]; then rm $zparseopts_errors; fi" EXIT

	# don't panic on error, we'll die later
	zparseopts -F -M -D -A command_line_options \
		$(help | help_opts) 2> $zparseopts_errors || :

	# die if errors were output
	if [[ -s $zparseopts_errors ]]; then
		die "$(cat $zparseopts_errors | sed 's/^[^ ]* //')"
	fi

	# process each option
	for k v in "${(@kv)command_line_options}"
	do process_option ${k#--} $v
	done

	# save the rest of the command-line arguments
	ARGUMENTS=("$@")
}

is_valid_8.3_path(){ local path="${1}"
	for segment in ${(s:\:)path}
	do [[ -z $segment ]] ||
		is_valid_8.3_path_segment "$segment" || return 1
	done
}

is_valid_8.3_path_segment(){ local filename=$1
	/usr/bin/grep -qE '^[A-Za-z0-9!#$%&'"'"'()@^_`{}~-]{1,8}(\.[A-Za-z0-9!#$%&'"'"'()@^_`{}~-]{0,3})?$' <<<"$filename"
}

reverse_forward_slashes(){
	sed 's|//*|\\|g'
}

version(){
	/usr/bin/awk '/^#!/{next}/^#/{sub("^# *","");print;next}{exit}' "$ZSH_ARGZERO"
}

die(){
	printf "%s\n" "$1">&2
	exit "${2:-1}"
}

help_opts(){ /usr/bin/awk '
# help_opts v1.0 2024-08-17

function initialize_option(){
	OPTION_BUFFER=""
	REQUIRED_ARGUMENT=0
	OPTIONAL_ARGUMENT=0
}
function add_option(name,key,req_arg,opt_arg){
	OPTIONS=OPTIONS" "name""(req_arg ? ":" : (opt_arg ? "::" : ""))(key?"="key:"")
}
function end_of_option(a,key,o){
	split(OPTION_BUFFER,a," ")
	key=a[1]
	delete a[1]
	add_option(key,"",REQUIRED_ARGUMENT,OPTIONAL_ARGUMENT)
	for (o in a) add_option(a[o],key,REQUIRED_ARGUMENT,OPTIONAL_ARGUMENT)
	initialize_option()
}
BEGIN{
	FS="[\t, ]+"
	initialize_option()
	OPTIONS=""
}
/\s*[^-]/{
	for ( f=1; f<=NF; f++)
		if ($f=="")
			continue
		else if (match($f, /^--?[a-zA-Z0-9][a-zA-Z0-9_-]*$/))
			OPTION_BUFFER=substr($f,2)" "OPTION_BUFFER
		else if (match($f, /^<.*>$/))
			REQUIRED_ARGUMENT=1
		else if (match($f, /^\[<.*>\]$/))
			OPTIONAL_ARGUMENT=1
		else
			end_of_option()
}
{
	if (OPTION_BUFFER) end_of_option()
}
END {
	print OPTIONS
}

'
}
main "$@"

